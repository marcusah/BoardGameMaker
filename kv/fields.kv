##################################################################
#                       Fields                                   #
##################################################################

#:import CARD conf.card_format


<.designed>
    designed: True
    sel_radius: 7
    canvas.after:
        #First, re-create the rotation effect of angle
        Rotate:
            angle: self.angle
            origin: self.center # if scatter self.width/2, self.height/2
            axis: 0,0,1
        #Border Frame - designer
        Color:
            rgba: (.2,.2,.2,1) if self.selected else (0,0,0,0)
        Line:
            rectangle: self.x, self.y, self.width, self.height
            dash_offset: 3
            dash_length: 5
        # Resize Band
        Line:
            circle: self.right-root.sel_radius, self.top-root.sel_radius, root.sel_radius/2
            width:2
        Line:
            width: 2
            circle: self.right-root.sel_radius, self.y+root.sel_radius, root.sel_radius/2
        Line:
            width: 2
            circle: self.x+root.sel_radius, self.top-root.sel_radius, root.sel_radius/2
        Line:
            width: 2
            circle: self.x+root.sel_radius, self.y+root.sel_radius, root.sel_radius/2
        Line:
            circle: self.center_x, self.top-root.sel_radius, root.sel_radius/2
            width:2
        Line:
            width: 2
            circle: self.center_x, self.y+root.sel_radius, root.sel_radius/2
        Line:
            width: 2
            circle: self.x+root.sel_radius, self.center_y, root.sel_radius/2
        Line:
            width: 2
            circle: self.right-root.sel_radius, self.center_y, root.sel_radius/2
        #End the rotation stuff for designed
        Rotate:
            angle: -self.angle
            origin: self.center # if scatter self.width/2, self.height/2
            axis: 0,0,1


    Label:
        is_context: True
        size_hint_y: None
        height: 20
        shorten: True
        shorten_from: 'left'
        halign: 'right'
        text: root.name if root.name else root.Type
        pos: (root.x, root.center_y-self.height) if root.Type!='TemplateField' else (0, root.height/2-self.height)
        color: (1,1,1,1) if root.hovered else (0,0,0,0)
        canvas.before:
            Color:
                rgba: (.7,.7,.7,1) if root.hovered else (0,0,0,0)
            Rectangle:
                pos: self.pos
                size: self.size
    Image:
        is_context: True
        source: "img/%s.png"%root.Type
        size_hint: None, None
        size: 24,24
        pos: (root.width/2-self.width/2, -self.height/2) if root.Type=='TemplateField' else (root.center_x-self.width/2, root.y-self.height/2)
        opacity: 1 if root.designed else 0


<Field>:
    size_hint: None, None
    size: 100,100
    sel_radius: 0
    canvas.before:
        PushMatrix
        Rotate:
            angle: self.angle
            origin: self.width/2, self.height/2 # self.center if floatlayout
            axis: 0,0,1
        Color:
            rgba: self.bg_color
        Rectangle:
            size: self.size
            pos: 0,0 #self.pos if floatlayout
    canvas.after:
        PopMatrix

<FloatField>:
    size_hint: None, None
    size: 100,100
    sel_radius: 0
    canvas.before:
        PushMatrix
        Rotate:
            angle: self.angle
            origin: self.center
            axis: 0,0,1
        Color:
            rgba: self.bg_color
        Rectangle:
            size: self.size
            pos: self.pos
    canvas.after:
        PopMatrix

<BGTemplate>:
    size: CARD.width, CARD.height

<ColorField>:
    canvas:
        Color:
            rgba:self.rgba
        Rectangle:
            #pos: self.pos
            size: self.size

<ColorChoiceField>:
    canvas:
        Color:
            rgba:self.rgba
        Rectangle:
            #pos: self.pos
            size: self.size

<BorderImageField>:
    canvas.before:
        Color:
            rgba: 1,1,1,1
        BorderImage:
            source: root.source
            border: (root.border_width,root.border_width,root.border_width,root.border_width)
            size:(self.width+2*root.border_width,self.height+2*root.border_width)
            pos: root.x-root.border_width,root.y-root.border_width

<BorderField>:
    canvas.before:
        Color:
            rgba: self.border_color
        Line:
            #if field is floatlayout: rounded_rectangle: self.x+self.border_width,self.y+self.border_width,self.width-2*self.border_width,self.height-2*self.border_width, self.border_radius
            rounded_rectangle: self.border_width,self.border_width,self.width-2*self.border_width,self.height-2*self.border_width, self.border_radius
            width: self.border_width

<ImageChoiceField>:
    source: self.choices[self.selection] if self.selection in self.choices else ""

<TransfoField>:
    canvas.before:
        Color:
            rgb: 1,1,1
        Rectangle:
            size: self.size
            texture: self.texture

<SubImageField>:
    canvas:
        Rectangle:
            #pos: self.pos
            size: self.size
            texture: self.texture

<RectangleField>:
    canvas:
        Color:
            rgba: self.line_color
        Line:
            width: self.line_width
            joint: self.joint
            cap: self.cap
            dash_length: self.dash_length
            dash_offset: self.dash_offset
            #if field is floatlayout rounded_rectangle: self.x,self.y,self.width, self.height, self.corner_radius
            rounded_rectangle: 0,0,self.width, self.height, self.corner_radius
        Color:
            rgba: self.fg_color
        # in 1.9.1 RoundedRectangle:
            #pos: self.pos
        Rectangle:
            size: self.size
            source: self.source
            texture: self.texture
            #in 1.9.1 radius: self.corner_radius

<EllipseField>:
    canvas:
        Color:
            rgba: self.line_color
        Line:
            width: self.line_width
            joint: self.joint
            cap: self.cap
            dash_length: self.dash_length
            dash_offset: self.dash_offset
            #if field is floatlayout ellipse: self.x, self.y, self.width, self.height, self.angle_start, self.angle_end
            ellipse: 0,0, self.width, self.height, self.angle_start, self.angle_end
        Color:
            rgba: self.fg_color
        Ellipse:
            #pos: self.pos
            size: self.size
            angle_start: self.angle_start
            angle_end: self.angle_end
            source: self.source
            texture: self.texture


#<LineField>:
#    canvas:
#        Color:
#            rgba: self.line_color
#        Line:
#            width: self.line_width
#            joint: self.joint
#            cap: self.cap
#            dash_length: self.dash_length
#            dash_offset: self.dash_offset
#            #if floatlayout: points: self.x, self.y, self.x+self.width, self.y+ self.height
#            points: 0,0, self.width, self.height

<PolygonField>:
    canvas:
        Color:
            rgba: self.line_color
        Mesh:
            vertices: self.vertices
            indices: range(self.side)
            mode: 'triangle_fan'
            source: self.source
            #source: 'images/judge.jpg'
            texture: self.texture

<WireField>:
    canvas:
        Color:
            rgba: self.line_color
        Line:
            width: self.line_width
            joint: self.joint
            cap: self.cap
            dash_length: self.dash_length
            dash_offset: self.dash_offset
            #if floatlayout points: [p*(self.height if i%2 else self.width) + (self.y if i%2 else self.x) for i,p in enumerate(self.points)]
            points: [p*(self.height if i%2 else self.width) for i,p in enumerate(self.points)]

<BezierField>:
    canvas:
        Color:
            rgba: self.line_color
        Line:
            width: self.line_width
            joint: self.joint
            cap: self.cap
            dash_length: self.dash_length
            dash_offset: self.dash_offset
            #if floatyout bezier: [p*(self.height if i%2 else self.width) + (self.y if i%2 else self.x) for i,p in enumerate(self.points)]
            bezier: [p*(self.height if i%2 else self.width) for i,p in enumerate(self.points)]

<MeshField>:
    canvas:
        Color:
            rgba: self.line_color
        Mesh:
            vertices: self.vertices
            indices: range(len(self.vertices)/4)
            mode: self.mode
            source: self.source
            texture: self.texture

<MaskField>:
    canvas.before:
        StencilPush
        Mesh:
            vertices: self.vertices
            indices: range(len(self.vertices)/4)
            mode: self.mode
            #source: self.source
            #texture: self.texture
        StencilUse
    canvas.after:
        #Remove mask
        StencilPop